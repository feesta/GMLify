<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
        <script src="https://raw.github.com/mrdoob/three.js/master/build/Three.js"></script>
        <style>
            body {
                background:#eee;
                padding:0;
                margin:0;
                overflow:hidden;
            }
            

        </style>
    </head>

    <body>
        <div id='main'></div>
        
        <script>

$(function(){

    getGML();


});


function getGML() {
    $.ajax({
        url:"http://000000book.com/data/random.json",
        // url:"./sample.json",
        dataType:"jsonp",
        success:function(data){
            // console.log(data);
            if (data['gml']['tag'] != undefined && data['gml']['tag']['drawing'] != undefined && data['gml']['tag']['drawing']['stroke'] != undefined) {
                console.info("GML id: " + data['id']);
                    
                var strokes = data['gml']['tag']['drawing']['stroke'];
                // console.info(points[0]['pt'][0]);


                // var i = 0;
                for (var s in strokes) {
                    var points = strokes[s]['pt'];
                    // console.log(points);
                    var prev_x = 0, prev_y = 0;
                    for (var p in points) {
                        // i ++;
                        if (!prev_x && !prev_y) {
                            prev_x = points[p]['x'];
                            prev_y = points[p]['y'];
                        } else {
                            var x = points[p]['x'],
                                y = points[p]['y'],
                                time = points[p]['time'] * 1000;

                                // console.info(prev_x,prev_y,x,y);
                                setTimeout((function(_prev_x,_prev_y,_x,_y, _time){
                                    return function(){
                                        scene.add(new Block(_prev_x,_prev_y,_x,_y, _time).cube);
                                        renderer.render(scene,camera);
                                    }
                                })(prev_x,prev_y,x,y,time), time);

                                prev_x = x;
                                prev_y = y;
                                // scene.add(block.cube);
                        }
                    }
                    // break;
                    // if (i > 20) break;
                }
            }
            // var pt0 = points[0]['pt'][0];
            // var pt1 = points[0]['pt'][1];
            // var block = new Block(pt0['x'],pt0['y'],pt1['x'],pt1['y']);
            // scene.add(block.cube);
            getGML();
        }
    });

    $(window).resize(function() {

    }).resize();
}

var $container,
    renderer,
    camera,
    scene;
var Z = 0;



var WIDTH = $(window).width();
var HEIGHT = $(window).height();

var VIEW_ANGLE = 45,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 0.1,
    FAR = 10000;
$container = $('#main');

// create a WebGL renderer, camera
// and a scene
renderer = new THREE.CanvasRenderer();
renderer.AA = false;
camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
scene = new THREE.Scene();
renderer.setSize(WIDTH, HEIGHT);
renderer.setClearColorHex(0xFFFFFF,1);

camera.position.x = 50;
camera.position.y = 50;
camera.position.z = 300;

$container.html("").append(renderer.domElement);

// set some camera attributes

// get the DOM element to attach to
// - assume we've got jQuery to hand





function Block(_x1,_y1,_x2,_y2,_time) {
    var scaleVal = 80;
    this.x1 = _x1 * scaleVal;
    this.y1 = _y1 * scaleVal;
    this.x2 = _x2 * scaleVal;
    this.y2 = _y2 * scaleVal;
    this.delay = _time;

    this.height = dist(this.x1,this.y1,this.x2,this.y2);
    if (this.height < 3) this.height = 3;
    // this.width = this.depth = 5;
    this.depth = scaleVal / (this.height + 5);
    this.width = this.depth * .6;
    
    this.anglez = this.x1 - this.x2 ? Math.atan((this.y1 - this.y2) / (this.x1 - this.x2)) : Math.atan((this.y1 - this.y2) / 0.000000001);

    // console.log(this.height, this.anglez, [this.x1, this.y1], [this.x2, this.y2], [(this.x1 - this.x2) / 2 + this.x2, (this.y1 - this.y2) / 2 + this.y2], (1 / (this.height + 50)));

    var sphereMaterial = new THREE.MeshBasicMaterial({color:get_random_color()});
    // var sphereMaterial = new THREE.MeshBasicMaterial({color:0x000000});

    this.cube = new THREE.Mesh(
        new THREE.CubeGeometry(this.width,this.height,this.depth,1,1,1, sphereMaterial),
        new THREE.MeshFaceMaterial());
    this.cube.position.y = (this.x1 - this.x2) / 2 + this.x2;
    this.cube.position.x = (this.y1 - this.y2) / 2 + this.y2;
    this.cube.position.z = Z;
    this.cube.rotation.x = Math.random() * .3;
    this.cube.rotation.y = Math.random() * .3;
    // this.cube.rotation.x = Math.random() * Math.PI;
    // this.cube.rotation.y = Math.random() * Math.PI;
    this.cube.rotation.z = -this.anglez;

    Z += 0.1;
    // camera.position.z += 1;
}

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

function get_random_color() {
    var letters = '0123456789ABCDEF'.split('');
    var color = '0x';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.round(Math.random() * 15)];
    }
    return color;
}


        </script>

    </body>
</html>









